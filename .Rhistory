geom_line() +
scale_y_continuous(sec.axis = sec_axis(trans = ~ (32 - .) * -5/9,
name = "Celsius")) +
labs(x = NULL, y = "Fahrenheit") +
theme_minimal()
ggplot(weather_atl, aes(x = time, y = temperatureHigh)) +
geom_line() +
scale_y_continuous(sec.axis = sec_axis(trans = ~ (. - 32) * 5/9 + 273.15,
name = "Kelvin")) +
labs(x = NULL, y = "Fahrenheit") +
theme_minimal()
# Temperature in Atlanta
temp_plot <- ggplot(weather_atl, aes(x = time, y = temperatureHigh)) +
geom_line() +
geom_smooth() +
scale_y_continuous(sec.axis = sec_axis(trans = ~ (32 - .) * -5/9,
name = "Celsius")) +
labs(x = NULL, y = "Fahrenheit") +
theme_minimal()
temp_plot
# Humidity in Atlanta
humidity_plot <- ggplot(weather_atl, aes(x = time, y = humidity)) +
geom_line() +
geom_smooth() +
labs(x = NULL, y = "Humidity") +
theme_minimal()
humidity_plot
library(patchwork)
temp_plot + humidity_plot
temp_plot + humidity_plot +
plot_layout(ncol = 1)
patch<- CD+CO+CR
patch+
plot_layout(ncol = 1)
patch<- CD+CO+CR
patch
temp_plot + humidity_plot +
plot_layout(ncol = 1, heights = c(0.7, 0.3))
library(GGally)
weather_correlations <- weather_atl %>%
select(temperatureHigh, temperatureLow, humidity, windSpeed, precipProbability)
ggpairs(weather_correlations)
library(GGally)
weather_correlations <- weather_atl %>%
select(temperatureHigh, temperatureLow, humidity, windSpeed, precipProbability)
ggpairs(weather_correlations)
result_predict <- lm(percent_dem ~ median_age + percent_white + per_capita_ income + loyer_médian + state,
result_predict <- lm(percent_dem ~ median_age + percent_white + per_capita_income + loyer_médian + state,
data = result)
result_predict <- lm(percent_dem ~ median_age + percent_white + per_capita_income + median_rent + state,
data = result)
result_coefs<- tidy(result_predict , conf.int = TRUE) %>%
filter(term != "(Intercept)") # Nous pouvons généralement ignorer le traçage de l'ordonnée
result_coefs
result_predict <- lm(percent_dem ~ median_age + percent_white + per_capita_income + median_rent + state,
data = result)
result_coefs<- tidy(result_predict , conf.int = TRUE)  %>%
filter(!str_detect(term, "state"))%>%
filter(term != "(Intercept)") # Nous pouvons généralement ignorer le traçage de l'ordonnée
result_coefs
result_predict <- lm(percent_dem ~ median_age + percent_white + per_capita_income + median_rent + state,
data = result)
result_coefs<- tidy(result_predict , conf.int = TRUE) %>%
filter(term != "(Intercept)") # Nous pouvons généralement ignorer le traçage de l'ordonnée
result_coefs
result_predict <- lm(percent_dem ~ median_age + percent_white + per_capita_income + median_rent + state,
data = result)
result_coefs<- tidy(result_predict , conf.int = TRUE)  %>%
filter(!str_detect(term, "state"))%>%
filter(term != "(Intercept)") # Nous pouvons généralement ignorer le traçage de l'ordonnée
result_coefs
model_complex <- lm(temperatureHigh ~ humidity_scaled + moonPhase_scaled +
precipProbability_scaled + windSpeed + pressure + cloudCover_scaled,
data = weather_atl_summer)
ggplot(weather_atl_summer,
aes(x = humidity_scaled, y = temperatureHigh)) +
geom_point() +
geom_smooth(method = "lm")
model_simple <- lm(temperatureHigh ~ humidity_scaled,
data = weather_atl_summer)
weather_atl_summer <- weather_atl %>%
filter(time >= "2019-05-01", time <= "2019-09-30") %>%
mutate(humidity_scaled = humidity * 100,
moonPhase_scaled = moonPhase * 100,
precipProbability_scaled = precipProbability * 100,
cloudCover_scaled = cloudCover * 100)
model_simple <- lm(temperatureHigh ~ humidity_scaled,
data = weather_atl_summer)
tidy(model_simple, conf.int = TRUE)
ggplot(weather_atl_summer,
aes(x = humidity_scaled, y = temperatureHigh)) +
geom_point() +
geom_smooth(method = "lm")
ggplot(result_predict,
aes(x = estimate, y = statistic)) +
geom_point() +
geom_smooth(method = "lm")
model_complex <- lm(temperatureHigh ~ humidity_scaled + moonPhase_scaled +
precipProbability_scaled + windSpeed + pressure + cloudCover_scaled,
data = weather_atl_summer)
tidy(model_complex, conf.int = TRUE)
model_tidied <- tidy(model_complex, conf.int = TRUE) %>%
filter(term != "(Intercept)")
ggplot(model_tidied,
aes(x = estimate, y = term)) +
geom_vline(xintercept = 0, color = "red", linetype = "dotted") +
geom_pointrange(aes(xmin = conf.low, xmax = conf.high)) +
labs(x = "Coefficient estimate", y = NULL) +
theme_minimal()
ggplot(result_coefs,
aes(x = estimate)) +
geom_vline(xintercept = 0, color = "red", linetype = "dotted") +
geom_pointrange(aes(xmin = conf.low, xmax = conf.high)) +
labs(x = "Coefficient estimate", y = NULL) +
theme_minimal()
ggplot(result_coefs,aes(x = estimate, y = term)) +
geom_vline(xintercept = 0, color = "red", linetype = "dotted") +
geom_pointrange(aes(xmin = conf.low, xmax = conf.high)) +
labs(x = "Coefficient estimate", y = NULL) +
theme_minimal()
my_predictions <- predictions(
model_name,
newdata = datagrid(per_capita_income = seq(9000, 60000, by = 100),
state = "Georgia"))
newdata_example <- tibble(humidity_scaled = 50, moonPhase_scaled = 50,
precipProbability_scaled = 50, windSpeed = 1,
pressure = 1000, cloudCover_scaled = 50)
newdata_example
# J'utilise select() ici car augment() renvoie des colonnes pour toutes les explications
# variables, et la colonne .fitted avec la valeur prédite est à l'extrême droite
# et est coupé
augment(model_complex, newdata = newdata_example, se_fit = TRUE) %>%
select(.fitted, .se.fit)
newdata <- tibble(windSpeed = seq(0, 8, 0.5),
pressure = mean(weather_atl_summer$pressure),
precipProbability_scaled = mean(weather_atl_summer$precipProbability_scaled),
moonPhase_scaled = mean(weather_atl_summer$moonPhase_scaled),
humidity_scaled = mean(weather_atl_summer$humidity_scaled),
cloudCover_scaled = mean(weather_atl_summer$cloudCover_scaled))
newdata
newdata <- tibble(windSpeed = seq(0, 8, 0.5),
pressure = mean(weather_atl_summer$pressure),
precipProbability_scaled = mean(weather_atl_summer$precipProbability_scaled),
moonPhase_scaled = mean(weather_atl_summer$moonPhase_scaled),
humidity_scaled = mean(weather_atl_summer$humidity_scaled),
cloudCover_scaled = mean(weather_atl_summer$cloudCover_scaled))
newdata
predicted_values <- augment(model_complex,
newdata = newdata,
se_fit = TRUE) %>%
mutate(conf.low = .fitted + (-1.96 * .se.fit),
conf.high = .fitted + (1.96 * .se.fit))
predicted_values %>%
select(windSpeed, .fitted, .se.fit, conf.low, conf.high) %>%
head()
ggplot(predicted_values, aes(x = windSpeed, y = .fitted)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
newdata_fancy <- expand_grid(windSpeed = seq(0, 8, 0.5),
pressure = mean(weather_atl_summer$pressure),
precipProbability_scaled = mean(weather_atl_summer$precipProbability_scaled),
moonPhase_scaled = mean(weather_atl_summer$moonPhase_scaled),
humidity_scaled = mean(weather_atl_summer$humidity_scaled),
cloudCover_scaled = c(0, 33, 66, 100))
newdata_fancy
predicted_values_fancy <- augment(model_complex,
newdata = newdata_fancy,
se_fit = TRUE) %>%
mutate(conf.low = .fitted + (-1.96 * .se.fit),
conf.high = .fitted + (1.96 * .se.fit)) %>%
# Faire de la couverture nuageuse une variable catégorique afin que nous puissions la facetter
mutate(cloudCover_scaled = factor(cloudCover_scaled))
ggplot(predicted_values_fancy, aes(x = windSpeed, y = .fitted)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = cloudCover_scaled),
alpha = 0.5) +
geom_line(aes(color = cloudCover_scaled), size = 1) +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal() +
guides(fill = "none", color = "none") +
facet_wrap(vars(cloudCover_scaled), nrow = 1)
my_predictions <- predictions(
model_name,
newdata = datagrid(per_capita_income = seq(9000, 60000, by = 100),
state = "Georgia"))
my_predictions <- predictions(
result,
newdata = datagrid(per_capita_income = seq(9000, 60000, by = 100),
state = "Georgia"))
# modele
model_complex <- lm(temperatureHigh ~ humidity_scaled + moonPhase_scaled +
precipProbability_scaled + windSpeed + pressure + cloudCover_scaled,
data = weather_atl_summer)
# mini jeu de donnée
newdata <- tibble(windSpeed = seq(0, 8, 0.5),
pressure = mean(weather_atl_summer$pressure),
precipProbability_scaled = mean(weather_atl_summer$precipProbability_scaled),
moonPhase_scaled = mean(weather_atl_summer$moonPhase_scaled),
humidity_scaled = mean(weather_atl_summer$humidity_scaled),
cloudCover_scaled = mean(weather_atl_summer$cloudCover_scaled))
# On met le mini jeu de donnée dans le modele
predicted_values <- augment(model_complex,
newdata = newdata,
se_fit = TRUE) %>%
mutate(conf.low = .fitted + (-1.96 * .se.fit),
conf.high = .fitted + (1.96 * .se.fit))
#  On regarde les valeurs prédites
predicted_values %>%
select(windSpeed, .fitted, .se.fit, conf.low, conf.high) %>%
head()
library(marginaleffects)
my_predictions <- predictions(
result_predict,
newdata = datagrid(per_capita_income = seq(9000, 60000, by = 100),
state = "Georgia"))
library(marginaleffects)
install.packages("marginaleffects")
library(marginaleffects)
my_predictions <- predictions(
result_predict,
newdata = datagrid(per_capita_income = seq(9000, 60000, by = 100),
state = "Georgia"))
library(marginaleffects)
# Calculer des prévisions sur une plage de vitesse du vent
predicted_values_easy <- predictions(model_complex,
newdata = datagrid(windSpeed = seq(0, 8, 0.5)))
# On regarde les valeurs prédites
predicted_values_easy %>%
select(windSpeed, predicted, std.error, conf.low, conf.high)
#library(marginaleffects)
# Calculer des prévisions sur une plage de vitesse du vent
predicted_values_easy <- predictions(model_complex,
newdata = datagrid(windSpeed = seq(0, 8, 0.5)))
# On regarde les valeurs prédites
predicted_values_easy %>%
select(windSpeed, predicted, std.error, conf.low, conf.high)
ggplot(predicted_values_easy, aes(x = windSpeed, y = predicted)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
my_predictions
slopes_wild <- marginaleffects(
model_wild,
newdata = datagrid(windSpeed = seq(0, 6, by = 0.1),
cloudCover_scaled = c(0, 33, 66, 100)),
variables = "windSpeed") %>%
mutate(cloudCover_scaled = factor(cloudCover_scaled))
ggplot(my_predictions, aes(x = windSpeed, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(my_predictions, aes(x = per_capita_income, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(my_predictions, aes(x = per_capita_income, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
my_predictions <- predictions(
result_predict,
newdata = datagrid(per_capita_income = seq(9000, 60000, by = 100),
state = "Georgia"))
ggplot(my_predictions, aes(x = per_capita_income, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(my_predictions, aes(x = per_capita_income)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(my_predictions, aes(x = per_capita_income, y =Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(my_predictions, aes(x = per_capita_income, y =Estimate))
ggplot(my_predictions, aes(x = per_capita_income, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
my_predictions
ggplot(my_predictions, aes(x = per_capita_income, y = Pr(>|z|)
ggplot(my_predictions, aes(x = per_capita_income, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
#library(marginaleffects)
# Calculer des prévisions sur une plage de vitesse du vent
predicted_values_easy <- predictions(model_complex,
newdata = datagrid(windSpeed = seq(0, 8, 0.5)))
ggplot(predicted_values_easy, aes(x = windSpeed, y = predicted)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
#library(marginaleffects)
# Calculer des prévisions sur une plage de vitesse du vent
predicted_values_easy <- predictions(model_complex,
newdata = datagrid(windSpeed = seq(0, 8, 0.5)))
# On regarde les valeurs prédites
predicted_values_easy %>%
select(windSpeed, predicted, std.error, conf.low, conf.high)
ggplot(my_predictions, aes(x = per_capita_income, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(my_predictions, aes(x = per_capita_income, y = S)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(my_predictions, aes(x = per_capita_income, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
my_predictions$Estimate <- as.numeric(my_predictions$Estimate)
my_predictions$Estimate <- as.numeric(my_predictions$Estimate)
my_predictions <- predictions(
result_predict,
newdata = datagrid(median_rent = seq(9000, 60000, by = 100),
state = "Georgia"))
my_predictions
ggplot(my_predictions, aes(x = median_rent, y = Estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
my_predictions$Estimate <- as.numeric(my_predictions$Estimate)
ggplot(my_predictions, aes(x = median_rent, y = estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(predicted_values_easy, aes(x = windSpeed, y = .fitted)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(predicted_values_easy, aes(x = windSpeed, y = fitted)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "Wind speed (MPH)", y = "Predicted high temperature (F)") +
theme_minimal()
ggplot(my_predictions, aes(x = median_rent, y = estimate)) +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
fill = "#BF3984", alpha = 0.5) +
geom_line(size = 1, color = "#BF3984") +
labs(x = "median_rent", y = "Predicted median_rent)") +
theme_minimal()
# Créer une matrice de corrélation
things_to_correlate <- result %>%
select(percent_dem , median_age , percent_white , per_capita_income , median_rent , state) %>%
cor()
# Créer une matrice de corrélation
things_to_correlate <- result %>%
select(percent_dem , median_age , percent_white , per_capita_income , median_rent ) %>%
cor()
things_to_correlate
# Créer une matrice de corrélation
things_to_correlate <- weather_atl %>%
select(temperatureHigh, temperatureLow, humidity, windSpeed, precipProbability) %>%
cor()
things_to_correlate
# Débarrassez-vous du triangle inférieur
things_to_correlate[lower.tri(things_to_correlate)] <- NA
things_to_correlate
things_to_correlate_long <- things_to_correlate %>%
# Convertir matrice en base de donnée
as.data.frame() %>%
# Les matrices ont des noms de colonne qui ne sont pas convertis en colonnes lors de l'utilisation
# as.data.frame(), donc cela ajoute ces noms en tant que colonne
rownames_to_column("measure2") %>%
# Rendez-le long. Prenez toutes les colonnes sauf measure2 et mettez leurs noms dans
# une colonne nommée measure1 et leurs valeurs dans une colonne nommée cor
pivot_longer(cols = -measure2,
names_to = "measure1",
values_to = "cor") %>%
# Créer une nouvelle colonne avec la version arrondie de la valeur de corrélation
mutate(nice_cor = round(cor, 2)) %>%
# Supprimer les lignes où les deux mesures sont identiques (comme la corrélation
# entre humidité et humidité)
filter(measure2 != measure1) %>%
# Débarrassez-vous du triangle vide
filter(!is.na(cor)) %>%
# Mettez ces catégories dans l'ordre
mutate(measure1 = fct_inorder(measure1),
measure2 = fct_inorder(measure2))
things_to_correlate_long
things_to_correlate_long <- things_to_correlate %>%
# Convertir matrice en base de donnée
as.data.frame() %>%
# Les matrices ont des noms de colonne qui ne sont pas convertis en colonnes lors de l'utilisation
# as.data.frame(), donc cela ajoute ces noms en tant que colonne
rownames_to_column("measure2") %>%
# Rendez-le long. Prenez toutes les colonnes sauf measure2 et mettez leurs noms dans
# une colonne nommée measure1 et leurs valeurs dans une colonne nommée cor
pivot_longer(cols = -measure2,
names_to = "measure1",
values_to = "cor") %>%
# Créer une nouvelle colonne avec la version arrondie de la valeur de corrélation
mutate(nice_cor = round(cor, 2)) %>%
# Supprimer les lignes où les deux mesures sont identiques (comme la corrélation
# entre humidité et humidité)
filter(measure2 != measure1) %>%
# Débarrassez-vous du triangle vide
filter(!is.na(cor)) %>%
# Mettez ces catégories dans l'ordre
mutate(measure1 = fct_inorder(measure1),
measure2 = fct_inorder(measure2))
things_to_correlate_long
# Créer une matrice de corrélation
t_to_correlate <- result %>%
select(percent_dem , median_age , percent_white , per_capita_income , median_rent ) %>%
cor()
t_to_correlate
t_to_correlate_long <- t_to_correlate %>%
# Convertir matrice en base de donnée
as.data.frame() %>%
# Les matrices ont des noms de colonne qui ne sont pas convertis en colonnes lors de l'utilisation
# as.data.frame(), donc cela ajoute ces noms en tant que colonne
rownames_to_column("measure2") %>%
# Rendez-le long. Prenez toutes les colonnes sauf measure2 et mettez leurs noms dans
# une colonne nommée measure1 et leurs valeurs dans une colonne nommée cor
pivot_longer(cols = -measure2,
names_to = "measure1",
values_to = "cor") %>%
# Créer une nouvelle colonne avec la version arrondie de la valeur de corrélation
mutate(nice_cor = round(cor, 2)) %>%
# Supprimer les lignes où les deux mesures sont identiques (comme la corrélation
# entre humidité et humidité)
filter(measure2 != measure1) %>%
# Débarrassez-vous du triangle vide
filter(!is.na(cor)) %>%
# Mettez ces catégories dans l'ordre
mutate(measure1 = fct_inorder(measure1),
measure2 = fct_inorder(measure2))
t_to_correlate_long
# Débarrassez-vous du triangle inférieur
t_to_correlate[lower.tri(things_to_correlate)] <- NA
t_to_correlate
t_to_correlate_long <- t_to_correlate %>%
# Convertir matrice en base de donnée
as.data.frame() %>%
# Les matrices ont des noms de colonne qui ne sont pas convertis en colonnes lors de l'utilisation
# as.data.frame(), donc cela ajoute ces noms en tant que colonne
rownames_to_column("measure2") %>%
# Rendez-le long. Prenez toutes les colonnes sauf measure2 et mettez leurs noms dans
# une colonne nommée measure1 et leurs valeurs dans une colonne nommée cor
pivot_longer(cols = -measure2,
names_to = "measure1",
values_to = "cor") %>%
# Créer une nouvelle colonne avec la version arrondie de la valeur de corrélation
mutate(nice_cor = round(cor, 2)) %>%
# Supprimer les lignes où les deux mesures sont identiques (comme la corrélation
# entre humidité et humidité)
filter(measure2 != measure1) %>%
# Débarrassez-vous du triangle vide
filter(!is.na(cor)) %>%
# Mettez ces catégories dans l'ordre
mutate(measure1 = fct_inorder(measure1),
measure2 = fct_inorder(measure2))
t_to_correlate_long
# Créer une matrice de corrélation
t_to_correlate <- result %>%
select( median_age , percent_white , per_capita_income , median_rent ) %>%
cor()
t_to_correlate
#Rangement des données
#resultat de vote par candidat selon l'Etat
result_vote_candidat<- result%>%
group_by(state)%>%
summarise(total1=sum(D),total2=sum(O),total3=sum(R),n=n())
#nous enlevons tous les na
result_vote_candidat <- na.omit(result_vote_candidat)
result_vote_candidat
#Rangement des données
#resultat de vote par candidat selon l'Etat
result_vote_candidat<- result%>%
group_by(state)%>%
summarise(total1=sum(D),total2=sum(O),total3=sum(R),n=n())
result<- read_csv("data/results_2016.csv")
result<- read_csv("data/results_2016.csv")
