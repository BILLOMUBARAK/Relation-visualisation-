---
title: "Relation"
author: "Mamadou Billo Diallo"
date: "2023-10-06"
output:
  word_document: default
  html_document: default
---

#Reflexion

En effet, sur ce chapitre nous étudions la relation entre les données tels que les doubles axes y pour pouvoir mettre ensemble 2 choses qui mesurent la même chose 
La corrélation pour savoir comment les données sont-elles corrélées.
La régression pour pouvoir faire des lignes et observés les résidus entre cette ligne et les données;
La prédiction aussi pour pouvoir prendre des décisions 
C’est un chapitre très complexe mais qui donne des bases solides pour pouvoir faire de la prédiction.
### Charger et nettoyer les données

Tout d'abord, nous chargeons les libraries que nous utiliserons :

```{r load-libraries, message=FALSE, warning=FALSE}
library(tidyverse)  
library(patchwork)  # Pour combiner des graphiques ggplots
library(GGally)     # pour les matrices de scatterplot 
library(broom)      # Pour convertir des objets modèles en jeu de données
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 6, fig.height = 3.6, fig.align = "center", collapse = TRUE)
set.seed(1234)
options("digits" = 2, "width" = 150)
```

```{r load-data-fake}
result<- read_csv("data/results_2016.csv")

```

#3 Graphiques de visualisation des données


```{r}
#Rangement des données 
#resultat de vote par candidat selon l'Etat
result_vote_candidat<- result%>%
  group_by(state)%>%
  summarise(total1=sum(D),total2=sum(O),total3=sum(R),n=n())
```

```{r}
#nous enlevons tous les na 
result_vote_candidat <- na.omit(result_vote_candidat)
result_vote_candidat

```

```{r}
#nous integrons le roboto condensed
windowsFonts(`Roboto Condensed` = windowsFont("Roboto Condensed"))
```
#graphe 1

```{r}
#graphe pour les resultats de vote du candidat democrate
CD1<-ggplot(result_vote_candidat,mapping = aes(x=n,y=total1))+
  geom_point(aes(colour = factor(state)),show.legend = FALSE)+
  # On utilise viridis
  scale_color_viridis_d(option = "plasma", end = 0.9) +
  labs(x = "nombre de vote par state", y = "total vote obtenu par le candidat",
       color = "state", size = "total1",
       title = "votes ",
       subtitle = "candidat democrate",
       caption = " MIT Election Data and Science Lab.") 

```

```{r}
CD2<-CD1+
  theme_minimal(base_family = "Roboto Condensed", base_size = 12) +
  theme(panel.grid.minor = element_blank(),
        # Titre en gras et plus gros
        plot.title = element_text(face = "bold", size = rel(1.7)),
        # Sous-titre simple, légèrement plus grand et gris
        plot.subtitle = element_text(face = "plain", size = rel(1.3), color = "grey70"),
        # Légende en italique, plus petite, grise et alignée à gauche
        plot.caption = element_text(face = "italic", size = rel(0.7), 
                                    color = "grey70", hjust = 0),
        # Titres de légende en gras
        legend.title = element_text(face = "bold"),
        # Titres de facettes en gras, légèrement plus grands, alignés à gauche pour des raisons de répétition
        strip.text = element_text(face = "bold", size = rel(1.1), hjust = 0),
        # Titres des axes en gras
        axis.title = element_text(face = "bold"),
        # Ajoutez un peu d'espace au-dessus du titre de l'axe des x et alignez-le à gauche
        axis.title.x = element_text(margin = margin(t = 10), hjust = 0),
        # Ajoutez un peu d'espace à droite du titre de l'axe des ordonnées et alignez-le en haut
        axis.title.y = element_text(margin = margin(r = 10), hjust = 1))
```

```{r}
CD<-CD2+
  # Ajouter un fond gris clair aux titres des facettes, sans bordures
  theme(strip.background = element_rect(fill = "grey90", color = NA),
        # Ajoutez une fine bordure grise autour de tous les tracés pour lier les titres des facettes
        panel.border = element_rect(color = "grey90", fill = NA))
```


```{r}
CD
```

#graphe 2


```{r}
#graphe pour les resultats de vote pour les autres candidats
CO1<-ggplot(result_vote_candidat,mapping = aes(x=n,y=total2))+
  geom_point(aes(colour = factor(state)),show.legend = FALSE)+
  # On utilise viridis
  scale_color_viridis_d(option = "plasma", end = 0.9) +
  labs(x = "nombre de vote par state", y = "total vote obtenu par les candidat",
       color = "state", size = "total2",
       title = "votes ",
       subtitle = "autres candidats",
       caption = " MIT Election Data and Science Lab.") 

```

```{r}
CO2<-CO1+
  theme_minimal(base_family = "Roboto Condensed", base_size = 12) +
  theme(panel.grid.minor = element_blank(),
        # Titre en gras et plus gros
        plot.title = element_text(face = "bold", size = rel(1.7)),
        # Sous-titre simple, légèrement plus grand et gris
        plot.subtitle = element_text(face = "plain", size = rel(1.3), color = "grey70"),
        # Légende en italique, plus petite, grise et alignée à gauche
        plot.caption = element_text(face = "italic", size = rel(0.7), 
                                    color = "grey70", hjust = 0),
        # Titres de légende en gras
        legend.title = element_text(face = "bold"),
        # Titres de facettes en gras, légèrement plus grands, alignés à gauche pour des raisons de répétition
        strip.text = element_text(face = "bold", size = rel(1.1), hjust = 0),
        # Titres des axes en gras
        axis.title = element_text(face = "bold"),
        # Ajoutez un peu d'espace au-dessus du titre de l'axe des x et alignez-le à gauche
        axis.title.x = element_text(margin = margin(t = 10), hjust = 0),
        # Ajoutez un peu d'espace à droite du titre de l'axe des ordonnées et alignez-le en haut
        axis.title.y = element_text(margin = margin(r = 10), hjust = 1))
```

```{r}
CO<-CO2+
  # Ajouter un fond gris clair aux titres des facettes, sans bordures
  theme(strip.background = element_rect(fill = "grey90", color = NA),
        # Ajoutez une fine bordure grise autour de tous les tracés pour lier les titres des facettes
        panel.border = element_rect(color = "grey90", fill = NA))
```


```{r}
CO
```


#graphe3


```{r}
#graphe pour les resultats de vote pour les autres candidats
CR1<-ggplot(result_vote_candidat,mapping = aes(x=n,y=total3))+
  geom_point(aes(colour = factor(state)),show.legend = FALSE)+
  # On utilise viridis
  scale_color_viridis_d(option = "plasma", end = 0.9) +
  scale_y_continuous(labels = scales::label_number())+
  labs(x = "nombre de vote par state", y = "total vote obtenu par le candidat repubicain ",
       color = "state", size = "total2",
       title = "votes ",
       subtitle = "candidat repubicain",
       caption = " MIT Election Data and Science Lab.") 

```

```{r}
CR2<-CR1+
  theme_minimal(base_family = "Roboto Condensed", base_size = 12) +
  theme(panel.grid.minor = element_blank(),
        # Titre en gras et plus gros
        plot.title = element_text(face = "bold", size = rel(1.7)),
        # Sous-titre simple, légèrement plus grand et gris
        plot.subtitle = element_text(face = "plain", size = rel(1.3), color = "grey70"),
        # Légende en italique, plus petite, grise et alignée à gauche
        plot.caption = element_text(face = "italic", size = rel(0.7), 
                                    color = "grey70", hjust = 0),
        # Titres de légende en gras
        legend.title = element_text(face = "bold"),
        # Titres de facettes en gras, légèrement plus grands, alignés à gauche pour des raisons de répétition
        strip.text = element_text(face = "bold", size = rel(1.1), hjust = 0),
        # Titres des axes en gras
        axis.title = element_text(face = "bold"),
        # Ajoutez un peu d'espace au-dessus du titre de l'axe des x et alignez-le à gauche
        axis.title.x = element_text(margin = margin(t = 10), hjust = 0),
        # Ajoutez un peu d'espace à droite du titre de l'axe des ordonnées et alignez-le en haut
        axis.title.y = element_text(margin = margin(r = 10), hjust = 1))
```

```{r}
CR<-CR2+
  # Ajouter un fond gris clair aux titres des facettes, sans bordures
  theme(strip.background = element_rect(fill = "grey90", color = NA),
        # Ajoutez une fine bordure grise autour de tous les tracés pour lier les titres des facettes
        panel.border = element_rect(color = "grey90", fill = NA))
```


```{r}
CR
```

```{r}
patch<- CD+CO+CR
patch

```


#predication

```{r}
result_predict <- lm(percent_dem ~ median_age + percent_white + per_capita_income + median_rent + state,
                    data = result)
result_coefs<- tidy(result_predict , conf.int = TRUE)  %>%
filter(!str_detect(term, "state"))%>% 
 filter(term != "(Intercept)") # Nous pouvons généralement ignorer le traçage de l'ordonnée                                           
result_coefs
```


```{r}
ggplot(result_coefs,aes(x = estimate, y = term)) +
  geom_vline(xintercept = 0, color = "red", linetype = "dotted") +
  geom_pointrange(aes(xmin = conf.low, xmax = conf.high)) + 
  labs(x = "Coefficient estimate", y = NULL) +
  theme_minimal()
```





median_rent et median_age ont un impact positif en moyenne de 0.16625 et  0.02003 sur y
per_capita_income n'a pas d'impact 
percent_white a un impact negatif en moyenne de -0.68228 sur y


```{r}
library(marginaleffects)

```


```{r}
my_predictions <- predictions(
result_predict,
newdata = datagrid(median_rent = seq(9000, 60000, by = 100),
state = "Georgia"))
```
```{r}
my_predictions
```




```{r mfx-plot-easy-pred}
ggplot(my_predictions, aes(x = median_rent, y = estimate)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
              fill = "#BF3984", alpha = 0.5) + 
  geom_line(size = 1, color = "#BF3984") +
  labs(x = "median_rent", y = "Predicted median_rent)") +
  theme_minimal()
```



























